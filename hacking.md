# Building #

## Configuration ##

The libsyscall_intercept repository uses CMake to generate a build system.
There is nothing really unusual about how cmake is used, so things should be
familiar for those who have already used cmake. Those who did not use cmake
before should probably take a little time to familiar with it:
 * How to use it: [Running CMake](https://cmake.org/runningcmake/)
 * How to develop cmake scipts: [CMake tutorial](https://cmake.org/cmake-tutorial/)

A simple example, generating an Eclipse project, and a ninja build system, both using the same source directory:
```sh
$ git clone https://github.com/pmem/syscall_intercept.git
$ mkdir syscall_intercept_debug_build
$ cd syscall_intercept_debug_build
$ cmake ../syscall_intercept -DCMAKE_BUILD_TYPE=Debug -G "Eclipse CDT4 - Unix Makefiles"
$ cd ..
$ mkdir syscall_intercept_debug_release
$ cd syscall_intercept_debug_release
$ cmake ../syscall_intercept -DCMAKE_BUILD_TYPE=Release -G ninja
```

Note: generating a ninja build system appeares to result in much faster
rebuilds in comparison to what makefiles allow.

## Build targets ##

Besides the usual build targets generated by cmake (all, test, clean, install, etc..), the following targets are available:
 * `cstyle` Checks coding style in c source files.
 * `check_whitespace` More coding style check, this target checks only some whitespace consitency.
 * `check-license` Checks for licenses in most source files, and the dates mentioned in those licenses.

## Running tests ##

The syscall_intercept library uses ctest. The ctest tests are generated by cmake, and can be executed simply by running ctest, e.g.:

```
$ ctest -R no_pie_intercept
Test project /home/tej/code/syscall_intercept/nbuild
    Start 30: prog_no_pie_intercept_libc_only
1/2 Test #30: prog_no_pie_intercept_libc_only ...   Passed    0.13 sec
    Start 32: prog_no_pie_intercept_all
2/2 Test #32: prog_no_pie_intercept_all .........   Passed    0.15 sec

100% tests passed, 0 tests failed out of 2

Total Test time (real) =   0.30 sec
```

See also: [CMake/Testing With CTest](https://cmake.org/Wiki/CMake/Testing_With_CTest)

# Internals #

## The syscall_intercept library upon startup: ##
 1) Looks for text sections of other object files loaded in the same process
 2) Gathers information about the locations of text sections in a `struct intercept_desc` structure, one per text section targeted for patching.
 3) Disassembles each text section, and stores information about each syscall instruction found in a `struct patch_desc` structure.
 4) Finally, applies the patches to each text section.

## Main source files ##

 * `src/intercept.h` containes the definition of `struct patch_desc` and `struct intercept_desc`
 * `src/entry.c` the entry point, called by the loader -- this file is not linked with the `asm_pattern*` tests
 * `src/intercept.c` contains the high level logic of intercepting
   * finding loaded object files
   * initiating the disassembly process (in intercept_desc.c)
   * initiating the patching process (in patcher.c)
   * providing an hook wrapper function, which can forward a syscall to a hook function provided by the user of the library
 * `src/intercept_desc.c` 

## How syscall_intercept finds text sections: ##

Position independent executable with a loadable segment at VirtAddr zero.
The base_addr might be different during each execution, due to ASLR.
```
$ echo "int main(){}" | cc -xc - -o dummy -pie

$ readelf -l dummy | grep "LOAD\|Offset\|file type" -A 1
Elf file type is DYN (Shared object file)
Entry point 0x530
--
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
--
  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x000000000000083c 0x000000000000083c  R E    0x200000
  LOAD           0x0000000000000de0 0x0000000000200de0 0x0000000000200de0
                 0x0000000000000230 0x0000000000000238  RW     0x200000

$ cat intercept_dummy.sh
INTERCEPT_ALL_OBJS=1 INTERCEPT_DEBUG_DUMP=1 \
  LD_PRELOAD=./libsyscall_intercept.so \
  ./dummy 2>&1 | grep "find_syscalls\|text mapped" | grep -o "dummy.*$"

$ ./intercept_dummy.sh
dummy at base_addr 0x0000560ea0b8d000
dummy .text mapped at 0x0000560ea0b8d530 - 0x0000560ea0b8d6e1
$ ./intercept_dummy.sh
dummy at base_addr 0x000055a379e63000
dummy .text mapped at 0x000055a379e63530 - 0x000055a379e636e1
$ ./intercept_dummy.sh
dummy at base_addr 0x000055d8dfae8000
dummy .text mapped at 0x000055d8dfae8530 - 0x000055d8dfae86e1
$ ./intercept_dummy.sh
dummy at base_addr 0x000055fc4402d000
dummy .text mapped at 0x000055fc4402d530 - 0x000055fc4402d6e1
```

Non position independent executable with a loadable segment
at VirtAddr 0x400000.
The base_addr is zero.
```

$ echo "int main(){}" | cc -xc - -o dummy -no-pie

$ readelf -l dummy | grep "LOAD\|Offset\|file type" -A 1
Elf file type is EXEC (Executable file)
Entry point 0x4003b0
--
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
--
  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                 0x000000000000063c 0x000000000000063c  R E    0x200000
  LOAD           0x0000000000000e48 0x0000000000600e48 0x0000000000600e48
                 0x00000000000001e0 0x00000000000001e8  RW     0x200000

$ ./intercept_dummy.sh
dummy at base_addr 0x0000000000000000
dummy .text mapped at 0x00000000004003b0 - 0x0000000000400531
$ ./intercept_dummy.sh
dummy at base_addr 0x0000000000000000
dummy .text mapped at 0x00000000004003b0 - 0x0000000000400531
$ ./intercept_dummy.sh
dummy at base_addr 0x0000000000000000
dummy .text mapped at 0x00000000004003b0 - 0x0000000000400531
$ ./intercept_dummy.sh
dummy at base_addr 0x0000000000000000
dummy .text mapped at 0x00000000004003b0 - 0x0000000000400531
``` 
